{
  "name": "sworm",
  "version": "0.4.0",
  "description": "a lightweight write-only ORM for MSSQL, MySQL, PostgreSQL",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "bluebird": "^2.2.2",
    "underscore": "^1.6.0"
  },
  "devDependencies": {
    "chai": "^1.9.1",
    "chai-as-promised": "^4.1.1",
    "mocha": "^1.21.4",
    "pogo": "^0.9.4",
    "mssql": "^1.1.1",
    "mysql": "^2.4.2",
    "pg": "^3.4.1"
  },
  "scripts": {
    "test": "mocha",
    "prepublish": "make"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/featurist/sworm.git"
  },
  "keywords": [
    "activerecord",
    "database",
    "postgres",
    "postgresql",
    "mysql",
    "orm",
    "mssql",
    "sqlserver",
    "sql",
    "server"
  ],
  "author": {
    "name": "Tim Macfarlane",
    "email": "timmacfarlane@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/featurist/sworm/issues"
  },
  "homepage": "https://github.com/featurist/sworm",
  "readme": "# SWORM\n\nA very lightweight **write only** Node.js ORM, with support for:\n\n* Microsoft SQL Server (MSSQL)\n* PostgreSQL\n* MySQL\n\n## NPM\n\n    npm install sworm\n\nThen install a database driver, one of:\n\n    npm install mssql\n    npm install pg\n    npm install mysql\n\nSee [sworm](https://www.npmjs.org/package/sworm) in NPM.\n\n## Write Only?\n\nThe features in this module are mostly for **writing graphs of related entities**. Querying, on the other hand, is done with raw SQL so you can do it fast. See the [query API](#queries) for details.\n\nThis ORM avoids some of the largest issues experienced in other ORMs:\n\n* query performance is too opaque\n* N+1 queries are frequently the default\n* configuring eager and lazy loading is tricky\n* one-to-many, many-to-one, many-to-many relationships are notoriously difficult to get right\n* lifecycle management of sessions and identity maps is rarely pleasant\n* check out the massive generated SQL statements!\n\nJust write SQL, you know how.\n\n## Example\n\n```JavaScript\nvar person = db.model({table: 'people'});\nvar address = db.model({table: 'addresses'});\n\nvar bob = person({\n  name: 'bob',\n  address: address({\n    address: 'Fremantle'\n  })\n});\n\nbob.save()\n```\n\nProduces:\n\n    -------- people ----------\n    | id | name | address_id |\n    --------------------------\n    | 11 | bob  | 22         |\n    --------------------------\n\n    ------- addresses ------\n    | id | address         |\n    ------------------------\n    | 22 | Fremantle       |\n    ------------------------\n\n## Connection\n\nConnect:\n\n```JavaScript\nvar sworm = require('sworm');\n\nsworm.db({\n  driver: 'mssql',\n  config: {\n    user: 'user',\n    password: 'password',\n    server: 'localhost',\n    database: 'databasename'\n  }\n}).then(function (db) {\n\n  var person = db.model({table: 'people'});\n  ...\n\n});\n```\n\nOr define models then connect:\n\n```JavaScript\nvar sworm = require('sworm');\n\nvar db = sworm.db();\n\nvar person = db.model({table: 'people'});\n\ndb.connect({\n  driver: 'mssql',\n  config: {\n    user: 'user',\n    password: 'password',\n    server: 'localhost',\n    database: 'databasename'\n  }\n}).then(function () {\n\n  ...\n\n});\n```\n\nConnection options:\n\n  * `driver`, one of `'mssql'`, `'mysql'` or `'pg'`.\n  * `config` connection options passed to the database driver of choice. See configuration options for: [SQL Server](https://github.com/patriksimek/node-mssql#configuration-1), [MySQL](https://github.com/felixge/node-mysql#connection-options), [PostgreSQL](https://github.com/brianc/node-postgres/wiki/pg#connectstring-connectionstring-function-callback).\n  * `url` a connection URL passed to the postgres driver. See the [`pg` url format](https://github.com/brianc/node-postgres/wiki/pg#connectstring-connectionstring-function-callback).\n  * `log`: either `true` to log SQL statements with `console.log()`\n\n    Can also be a function for custom logging:\n\n    ```JavaScript\n    function (sql, params) {\n      // sql == 'select * from people where name = @name'\n      // params == {name: 'bob'}\n    }\n    ```\n\n    Defaults to `false`, no logging.\n\n### Close\n\nClose the connection after use:\n\n```JavaScript\ndb.close()\n```\n\n## Models\n\n```JavaScript\nvar createEntity = db.model(options);\n```\n\n`options` can contain the following:\n\n  * `table` (`undefined`) the name of the table to save entities to\n  * `id` (`'id'`) the name of the identity column. This can be an array of id columns for compound keys.\n  * `foreignKeyFor` a function that returns a foreign key field name for a member (see [Relationships](#relationships)), defaults to:\n\n    ```JavaScript\n    function foreignKeyFor(fieldName) {\n      return fieldName + '_id';\n    }\n    ```\n\n`createEntity` is a function that can be used to create entities from the model.\n\n### Model Methods\n\nAny other properties or functions on the `options` object are accessible by entities.\n\n```JavaScript\nvar address = db.model({\n  table: 'addresses',\n\n  function: addPerson(person) {\n    this.people = this.people || [];\n    person.address = this;\n    this.people.push(person);\n  }\n});\n\nvar fremantle = address({address: 'Fremantle'});\nfremantle.addPerson(person({name: 'bob'}));\n```\n\n## Entities\n\nThe entity constructor takes an object with fields to be saved to the database.\n\n```JavaScript\nvar person = db.model({...});\n\nvar bob = person({\n  name: 'bob'\n}, [options]);\n```\n\nWhere options can have:\n  * `saved`: if `true` will `update` the entity (if modified) on the next `save()`, if `false` will `insert` the entity on the next `save()`. Default `false`.\n  * `modified`: if `true` (and if `saved` is true), will `update` the entity on the next `save()` regardless if it has been modified.\n\n### Save\n\n```JavaScript\nvar promise = entity.save([options]);\n```\n\nInserts or updates the entity into the table. If the entity already has a value for its identity column, then it is updated, if not, it is inserted.\n\nObjects know when they've been modified since their last insert or update, so they won't update unless a field is modified. You can force an update by passing `{force: true}`.\n\n`save()` returns a promise.\n\n### Identity\n\n```JavaScript\nentity.identity()\n```\n\nReturns the ID of the entity, based on the identity column specified in the model.\n\n### Changed\n\n```JavaScript\nentity.changed()\n```\n\nReturns true if the object has been modified since the last `save()`.\n\n## Relationships\n\nEntities can contain fields that are other entities. This way you can build up graphs of entities and save them all in one go.\n\n### Many to One\n\nWhen entity A contains a field that is entity B, then B will be saved first and B's ID will be set and saved with A.\n\nThe foreign key of the member will be saved on the field name `member_id`. So `address` will have a foreign key of `address_id`. See the `foreignKeyFor` option in [Models](#models).\n\n```JavaScript\nvar person = db.model({table: 'people'});\nvar address = db.model({table: 'addresses'});\n\nvar bob = person({\n  name: 'bob',\n  address: address({\n    address: \"15 Rue d'Essert\"\n  })\n});\n\nbob.save().then(function () {\n  assert(bob.address_id == address.id);\n});\n```\n\nIn SQL:\n\n    -------- people ----------\n    | id | name | address_id |\n    --------------------------\n    | 11 | bob  | 22         |\n    --------------------------\n\n    ------- addresses ------\n    | id | address         |\n    ------------------------\n    | 22 | 15 Rue d'Essert |\n    ------------------------\n\n### One to Many\n\nWhen entity A contains a field that is an array that contains entities B and C. Then entity A will be saved first, followed by all entities B and C.\n\nThis allows entities B and C to refer to entity A, as they would in their tables.\n\n```JavaScript\nvar person = db.model({ table: 'people' });\nvar address = db.model({ table: 'addresses' });\n\nvar bob = person({name: 'bob'});\nvar jane = person({name: 'jane'});\n\nvar essert = address({\n  address: \"15 Rue d'Essert\",\n  people: [bob, jane]\n});\n\nbob.address = essert;\njane.address = essert;\n\nessert.save().then(function () {\n  // all objects saved.\n});\n```\n\nAlternatively, we can return the people in the address using a function. When the address is saved, the `people` function will be called with the owner address as `this`, then we can set the foreign key for the people.\n\n```JavaScript\nvar person = db.model({ table: 'people' });\nvar address = db.model({ table: 'addresses' });\n\nvar essert = address({\n  address: \"15 Rue d'Essert\",\n  people: function() {\n    return [\n      person({ name: 'bob', address: this }),\n      person({ name: 'jane', address: this })\n    ];\n  }\n});\n\nessert.save().then(function () {\n  // all objects saved.\n});\n```\n\nNotice that whether we use an array or a function, the field itself is never saved to the database, only the entities inside the array.\n\nIn SQL:\n\n    -------- people ----------\n    | id | name | address_id |\n    --------------------------\n    | 11 | bob  | 22         |\n    | 12 | jane | 22         |\n    --------------------------\n\n    ------- addresses ------\n    | id | address         |\n    ------------------------\n    | 22 | 15 Rue d'Essert |\n    ------------------------\n\n### Many to Many\n\nMany-to-many is just a combination of one-to-many and many-to-one:\n\n```JavaScript\nvar person = db.model({ table: 'people' });\nvar personAddress = db.model({ table: 'people_addresses', id: ['address_id', 'person_id'] });\nvar address = db.model({ table: 'addresses' });\n\nfunction personLivesInAddress(person, address) {\n  pa = personAddress({person: person, address: address});\n\n  person.addresses = person.addresses || [];\n  person.addresses.push(pa);\n\n  address.people = address.people || [];\n  address.people.push(pa);\n}\n\nvar bob = person({name: 'bob'});\nvar jane = person({name: 'jane'});\n\nvar fremantle = address({\n  address: \"Fremantle\"\n});\nvar essert = address({\n  address: \"15 Rue d'Essert\"\n});\n\npersonLivesInAddress(bob, fremantle);\npersonLivesInAddress(jane, fremantle);\npersonLivesInAddress(jane, essert);\n\nPromise.all([essert.save(), fremantle.save()]);\n```\n\nIn SQL:\n\n    -- people ---\n    | id | name |\n    -------------\n    | 11 | bob  |\n    | 12 | jane |\n    -------------\n\n    ------- addresses ------\n    | id | address         |\n    ------------------------\n    | 22 | 15 Rue d'Essert |\n    | 23 | Fremantle       |\n    ------------------------\n\n    ---- people_addresses ----\n    | address_id | person_id |\n    --------------------------\n    | 22         | 12        |\n    | 23         | 12        |\n    | 23         | 11        |\n    --------------------------\n\n# Queries\n\n```JavaScript\nvar records = db.query(sql, [parameters]);\n```\n\nWhere:\n\n  * `sql` is the SQL query, can be a query (i.e. select), or a command (update, insert, stored proc)\n  * `parameters`. If `sql` contains parameters in the form of `@paramName` the corresponding property on the `parameters` object will be substituted into the SQL, doing any escaping necessary.\n\nFor select queries, returns an array of objects, containing the fields of each record.\n\n## Model Queries\n\n```JavaScript\nvar entities = model.query(sql, [parameters]);\n```\n\nSame as `db.query()` but records returned are turned into entities of the model that can subsequently be modified and saved.\n",
  "readmeFilename": "readme.md",
  "_id": "sworm@0.4.0",
  "_from": "sworm@"
}
